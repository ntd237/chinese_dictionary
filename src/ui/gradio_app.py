"""
Giao di·ªán Gradio cho ·ª©ng d·ª•ng tra c·ª©u t·ª´ H√°n Vi·ªát
===============================================

T·∫°o giao di·ªán web t∆∞∆°ng t√°c cho ph√©p ng∆∞·ªùi d√πng:
- Nh·∫≠p t·ª´/c·ª•m t·ª´ ti·∫øng Trung (ch·ªØ H√°n)
- Xem phi√™n √¢m Pinyin v·ªõi d·∫•u thanh
- Xem b·∫£n d·ªãch nghƒ©a ti·∫øng Vi·ªát
- X·ª≠ l√Ω batch input v√† hi·ªÉn th·ªã k·∫øt qu·∫£ d·∫°ng b·∫£ng
"""

import logging
import gradio as gr
import pandas as pd
from typing import List, Tuple, Dict, Any, Optional
import sys
import os

# Th√™m src v√†o Python path ƒë·ªÉ import modules
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from pinyin_converter import get_converter, PinyinConverter
from api_handler import get_translation_handler, TranslationAPIHandler

# C·∫•u h√¨nh logging
logger = logging.getLogger(__name__)


class HanVietApp:
    """
    Class ch√≠nh cho ·ª©ng d·ª•ng Gradio tra c·ª©u t·ª´ H√°n Vi·ªát.
    """

    def __init__(self):
        """Kh·ªüi t·∫°o app v·ªõi c√°c components c·∫ßn thi·∫øt."""
        self.pinyin_converter = get_converter()
        self.translation_handler = get_translation_handler()
        
        # C·∫•u h√¨nh UI
        self.title = "üî§ T·ª´ ƒëi·ªÉn H√°n Vi·ªát - Pinyin & D·ªãch nghƒ©a"
        self.description = """
        **Tra c·ª©u t·ª´ H√°n Vi·ªát v·ªõi phi√™n √¢m Pinyin chu·∫©n v√† d·ªãch nghƒ©a ti·∫øng Vi·ªát**
        
        ‚ú® **T√≠nh nƒÉng:**
        - üéØ Chuy·ªÉn ƒë·ªïi ch·ªØ H√°n sang Pinyin c√≥ d·∫•u thanh
        - üåè D·ªãch nghƒ©a t·ª´ ti·∫øng Trung sang ti·∫øng Vi·ªát
        - üìù H·ªó tr·ª£ t·ª´ ƒë∆°n v√† c·ª•m t·ª´
        - ‚ö° X·ª≠ l√Ω nhanh v·ªõi cache th√¥ng minh
        
        üìå **C√°ch s·ª≠ d·ª•ng:** Nh·∫≠p ch·ªØ H√°n v√†o √¥ b√™n d∆∞·ªõi v√† nh·∫•n "Tra c·ª©u"
        """
        
    def process_single_word(
        self, 
        chinese_input: str, 
        include_tone: bool = True,
        show_analysis: bool = False
    ) -> Tuple[str, str, str, str]:
        """
        X·ª≠ l√Ω tra c·ª©u cho m·ªôt t·ª´/c·ª•m t·ª´.

        Args:
            chinese_input (str): Input ch·ªØ H√°n
            include_tone (bool): Bao g·ªìm d·∫•u thanh trong Pinyin
            show_analysis (bool): Hi·ªÉn th·ªã ph√¢n t√≠ch chi ti·∫øt

        Returns:
            Tuple[str, str, str, str]: (pinyin, translation, analysis, status)
        """
        if not chinese_input or not chinese_input.strip():
            return "", "", "", "‚ùå Vui l√≤ng nh·∫≠p ch·ªØ H√°n c·∫ßn tra c·ª©u"

        chinese_text = chinese_input.strip()
        
        try:
            # Chuy·ªÉn ƒë·ªïi Pinyin
            logger.info(f"ƒêang x·ª≠ l√Ω: '{chinese_text}'")
            pinyin_result = self.pinyin_converter.convert_to_pinyin(
                chinese_text, 
                with_tone=include_tone
            )
            
            # D·ªãch nghƒ©a
            success, translation, endpoint = self.translation_handler.translate_text(chinese_text)
            
            if not success:
                translation = f"[Kh√¥ng th·ªÉ d·ªãch: {translation}]"
                status = f"‚ö†Ô∏è Pinyin: OK, D·ªãch: L·ªói (endpoint: {endpoint})"
            else:
                status = f"‚úÖ Th√†nh c√¥ng (d·ªãch via: {endpoint})"
            
            # Ph√¢n t√≠ch chi ti·∫øt (n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu v√† l√† k√Ω t·ª± ƒë∆°n)
            analysis = ""
            if show_analysis and len(chinese_text) == 1:
                char_analysis = self.pinyin_converter.analyze_character(chinese_text)
                if "error" not in char_analysis:
                    analysis = f"""
**Ph√¢n t√≠ch chi ti·∫øt cho '{chinese_text}':**
- Pinyin c√≥ d·∫•u: {char_analysis.get('pinyin_tone', 'N/A')}
- Pinyin kh√¥ng d·∫•u: {char_analysis.get('pinyin_no_tone', 'N/A')}
- S·ªë thanh: {char_analysis.get('tone_number', 'N/A')}
- L√† ch·ªØ H√°n: {char_analysis.get('is_chinese', 'N/A')}
                    """.strip()
            
            return pinyin_result, translation, analysis, status
            
        except Exception as e:
            logger.error(f"L·ªói x·ª≠ l√Ω '{chinese_text}': {e}")
            return "", f"[L·ªói: {e}]", "", f"‚ùå L·ªói x·ª≠ l√Ω: {e}"

    def process_batch_words(
        self, 
        batch_input: str, 
        include_tone: bool = True
    ) -> pd.DataFrame:
        """
        X·ª≠ l√Ω batch nhi·ªÅu t·ª´.

        Args:
            batch_input (str): Input nhi·ªÅu t·ª´, m·ªói t·ª´ m·ªôt d√≤ng
            include_tone (bool): Bao g·ªìm d·∫•u thanh

        Returns:
            pd.DataFrame: K·∫øt qu·∫£ d·∫°ng b·∫£ng
        """
        if not batch_input or not batch_input.strip():
            return pd.DataFrame({"Th√¥ng b√°o": ["Vui l√≤ng nh·∫≠p danh s√°ch t·ª´ c·∫ßn tra c·ª©u (m·ªói t·ª´ m·ªôt d√≤ng)"]})

        # T√°ch t·ª´ng d√≤ng
        lines = [line.strip() for line in batch_input.strip().split('\n') if line.strip()]
        
        if not lines:
            return pd.DataFrame({"Th√¥ng b√°o": ["Kh√¥ng c√≥ t·ª´ h·ª£p l·ªá ƒë·ªÉ x·ª≠ l√Ω"]})

        logger.info(f"X·ª≠ l√Ω batch {len(lines)} t·ª´")
        
        # X·ª≠ l√Ω Pinyin
        pinyin_results = self.pinyin_converter.convert_word_list(lines, with_tone=include_tone)
        
        # X·ª≠ l√Ω d·ªãch
        translation_results = self.translation_handler.translate_batch(lines)
        
        # K·∫øt h·ª£p k·∫øt qu·∫£
        data = []
        for i, word in enumerate(lines):
            pinyin = pinyin_results[i]["pinyin"] if i < len(pinyin_results) else "[L·ªói]"
            
            translation_info = next((r for r in translation_results if r["original"] == word), None)
            if translation_info and translation_info["success"]:
                translation = translation_info["translation"]
                status = f"‚úÖ ({translation_info['endpoint']})"
            else:
                translation = f"[L·ªói: {translation_info['error'] if translation_info else 'Kh√¥ng t√¨m th·∫•y'}]"
                status = "‚ùå L·ªói"
            
            data.append({
                "STT": i + 1,
                "Ch·ªØ H√°n": word,
                "Pinyin": pinyin,
                "Nghƒ©a ti·∫øng Vi·ªát": translation,
                "Tr·∫°ng th√°i": status
            })
        
        df = pd.DataFrame(data)
        logger.info(f"Ho√†n th√†nh batch: {len([d for d in data if d['Tr·∫°ng th√°i'].startswith('‚úÖ')])}/{len(data)} th√†nh c√¥ng")
        
        return df

    def get_cache_info(self) -> Tuple[str, str]:
        """
        L·∫•y th√¥ng tin cache.

        Returns:
            Tuple[str, str]: (pinyin_info, translation_info)
        """
        try:
            # Translation cache stats
            trans_stats = self.translation_handler.get_cache_stats()
            trans_info = f"""
**Cache d·ªãch thu·∫≠t:**
- S·ªë entries: {trans_stats['total_entries']}
- K√≠ch th∆∞·ªõc file: {trans_stats['cache_file_size_bytes']} bytes
- File t·ªìn t·∫°i: {'‚úÖ' if trans_stats['cache_file_exists'] else '‚ùå'}
            """.strip()
            
            # Pinyin info (kh√¥ng c√≥ cache ri√™ng, nh∆∞ng c√≥ th·ªÉ hi·ªÉn th·ªã stats kh√°c)
            pinyin_info = f"""
**Th√¥ng tin Pinyin converter:**
- S·ª≠ d·ª•ng th∆∞ vi·ªán: pypinyin
- Style m·∫∑c ƒë·ªãnh: TONE (c√≥ d·∫•u thanh)
- H·ªó tr·ª£: Ch·ªØ H√°n simplified & traditional
            """.strip()
            
            return pinyin_info, trans_info
            
        except Exception as e:
            logger.error(f"L·ªói l·∫•y cache info: {e}")
            return f"L·ªói: {e}", f"L·ªói: {e}"

    def clear_translation_cache(self) -> str:
        """
        X√≥a cache d·ªãch thu·∫≠t.

        Returns:
            str: Th√¥ng b√°o k·∫øt qu·∫£
        """
        try:
            cleared_count = self.translation_handler.clear_cache()
            return f"‚úÖ ƒê√£ x√≥a {cleared_count} entries kh·ªèi cache d·ªãch thu·∫≠t"
        except Exception as e:
            logger.error(f"L·ªói x√≥a cache: {e}")
            return f"‚ùå L·ªói x√≥a cache: {e}"


def create_interface() -> gr.Interface:
    """
    T·∫°o giao di·ªán Gradio ch√≠nh.

    Returns:
        gr.Interface: Gradio interface object
    """
    app = HanVietApp()
    
    # Custom CSS cho giao di·ªán ƒë·∫πp h∆°n
    custom_css = """
    .gradio-container {
        max-width: 1200px !important;
        margin: auto !important;
    }
    .tab-nav {
        font-size: 16px !important;
    }
    .output-markdown {
        font-size: 14px !important;
    }
    """
    
    with gr.Blocks(
        title=app.title,
        css=custom_css,
        theme=gr.themes.Soft()
    ) as interface:
        
        # Header
        gr.Markdown(f"# {app.title}")
        gr.Markdown(app.description)
        
        with gr.Tabs():
            # Tab 1: Tra c·ª©u ƒë∆°n
            with gr.TabItem("üîç Tra c·ª©u t·ª´ ƒë∆°n"):
                with gr.Row():
                    with gr.Column(scale=2):
                        chinese_input = gr.Textbox(
                            label="Nh·∫≠p ch·ªØ H√°n",
                            placeholder="V√≠ d·ª•: ‰Ω†Â•Ω, ‰∏≠ÂõΩ, Â≠¶‰π†...",
                            lines=2,
                            max_lines=3
                        )
                        
                        with gr.Row():
                            include_tone = gr.Checkbox(
                                label="Bao g·ªìm d·∫•u thanh trong Pinyin", 
                                value=True
                            )
                            show_analysis = gr.Checkbox(
                                label="Hi·ªÉn th·ªã ph√¢n t√≠ch chi ti·∫øt (ch·ªâ cho k√Ω t·ª± ƒë∆°n)",
                                value=False
                            )
                        
                        lookup_btn = gr.Button("üîç Tra c·ª©u", variant="primary", size="lg")
                    
                    with gr.Column(scale=3):
                        pinyin_output = gr.Textbox(
                            label="üìù Phi√™n √¢m Pinyin",
                            interactive=False,
                            lines=2
                        )
                        
                        translation_output = gr.Textbox(
                            label="üåè Nghƒ©a ti·∫øng Vi·ªát", 
                            interactive=False,
                            lines=3
                        )
                        
                        analysis_output = gr.Markdown(
                            label="üî¨ Ph√¢n t√≠ch chi ti·∫øt",
                            visible=True
                        )
                        
                        status_output = gr.Textbox(
                            label="üìä Tr·∫°ng th√°i",
                            interactive=False,
                            lines=1
                        )
                
                # K·∫øt n·ªëi events
                lookup_btn.click(
                    fn=app.process_single_word,
                    inputs=[chinese_input, include_tone, show_analysis],
                    outputs=[pinyin_output, translation_output, analysis_output, status_output]
                )
                
                # Enter key support
                chinese_input.submit(
                    fn=app.process_single_word,
                    inputs=[chinese_input, include_tone, show_analysis],
                    outputs=[pinyin_output, translation_output, analysis_output, status_output]
                )
            
            # Tab 2: Tra c·ª©u batch
            with gr.TabItem("üìã Tra c·ª©u nhi·ªÅu t·ª´"):
                with gr.Row():
                    with gr.Column(scale=1):
                        batch_input = gr.Textbox(
                            label="Danh s√°ch t·ª´ c·∫ßn tra c·ª©u",
                            placeholder="Nh·∫≠p m·ªói t·ª´/c·ª•m t·ª´ tr√™n m·ªôt d√≤ng:\n‰Ω†Â•Ω\n‰∏≠ÂõΩ\nÂ≠¶‰π†\n...",
                            lines=10,
                            max_lines=15
                        )
                        
                        batch_tone = gr.Checkbox(
                            label="Bao g·ªìm d·∫•u thanh trong Pinyin",
                            value=True
                        )
                        
                        batch_btn = gr.Button("üìã Tra c·ª©u t·∫•t c·∫£", variant="primary", size="lg")
                    
                    with gr.Column(scale=2):
                        batch_output = gr.DataFrame(
                            label="üìä K·∫øt qu·∫£ tra c·ª©u",
                            headers=["STT", "Ch·ªØ H√°n", "Pinyin", "Nghƒ©a ti·∫øng Vi·ªát", "Tr·∫°ng th√°i"],
                            datatype=["number", "str", "str", "str", "str"],
                            interactive=False
                        )
                
                batch_btn.click(
                    fn=app.process_batch_words,
                    inputs=[batch_input, batch_tone],
                    outputs=[batch_output]
                )
            
            # Tab 3: Th√¥ng tin & C√†i ƒë·∫∑t
            with gr.TabItem("‚öôÔ∏è Th√¥ng tin & Cache"):
                with gr.Row():
                    with gr.Column():
                        gr.Markdown("### üìã Th√¥ng tin h·ªá th·ªëng")
                        
                        cache_btn = gr.Button("üîÑ L√†m m·ªõi th√¥ng tin cache")
                        
                        pinyin_info = gr.Markdown(
                            label="üìù Pinyin Converter",
                            value="Click 'L√†m m·ªõi th√¥ng tin cache' ƒë·ªÉ xem"
                        )
                        
                        translation_info = gr.Markdown(
                            label="üåè Translation Handler", 
                            value="Click 'L√†m m·ªõi th√¥ng tin cache' ƒë·ªÉ xem"
                        )
                    
                    with gr.Column():
                        gr.Markdown("### üóëÔ∏è Qu·∫£n l√Ω Cache")
                        
                        clear_cache_btn = gr.Button("üóëÔ∏è X√≥a cache d·ªãch thu·∫≠t", variant="secondary")
                        
                        cache_status = gr.Textbox(
                            label="Tr·∫°ng th√°i",
                            value="S·∫µn s√†ng",
                            interactive=False
                        )
                        
                        gr.Markdown("""
                        ### ‚ÑπÔ∏è H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
                        
                        1. **Tra c·ª©u ƒë∆°n**: Nh·∫≠p m·ªôt t·ª´/c·ª•m t·ª´ ƒë·ªÉ xem Pinyin v√† nghƒ©a
                        2. **Tra c·ª©u batch**: Nh·∫≠p nhi·ªÅu t·ª´ (m·ªói d√≤ng m·ªôt t·ª´) ƒë·ªÉ x·ª≠ l√Ω h√†ng lo·∫°t
                        3. **Cache**: H·ªá th·ªëng t·ª± ƒë·ªông l∆∞u k·∫øt qu·∫£ d·ªãch ƒë·ªÉ tƒÉng t·ªëc l·∫ßn tra c·ª©u ti·∫øp theo
                        4. **D·∫•u thanh**: B·∫°n c√≥ th·ªÉ ch·ªçn hi·ªÉn th·ªã Pinyin c√≥ ho·∫∑c kh√¥ng c√≥ d·∫•u thanh
                        
                        **API s·ª≠ d·ª•ng**: LibreTranslate (mi·ªÖn ph√≠), pypinyin
                        """)
                
                # K·∫øt n·ªëi events
                cache_btn.click(
                    fn=app.get_cache_info,
                    inputs=[],
                    outputs=[pinyin_info, translation_info]
                )
                
                clear_cache_btn.click(
                    fn=app.clear_translation_cache,
                    inputs=[],
                    outputs=[cache_status]
                )
        
        # Footer
        gr.Markdown("""
        ---
        **üî§ T·ª´ ƒëi·ªÉn H√°n Vi·ªát** | ƒê∆∞·ª£c ph√°t tri·ªÉn b·∫±ng Python, Gradio, pypinyin & LibreTranslate | 
        üìß B√°o l·ªói ho·∫∑c g√≥p √Ω qua Issues
        """)
    
    return interface


def launch_app(
    server_name: str = "127.0.0.1",
    server_port: int = 7860,
    share: bool = False,
    debug: bool = False
) -> None:
    """
    Kh·ªüi ch·∫°y ·ª©ng d·ª•ng Gradio.

    Args:
        server_name (str): ƒê·ªãa ch·ªâ server (m·∫∑c ƒë·ªãnh localhost)
        server_port (int): Port (m·∫∑c ƒë·ªãnh 7860)
        share (bool): T·∫°o public link kh√¥ng (m·∫∑c ƒë·ªãnh False)
        debug (bool): Ch·∫ø ƒë·ªô debug (m·∫∑c ƒë·ªãnh False)
    """
    logger.info("ƒêang kh·ªüi ƒë·ªông ·ª©ng d·ª•ng Gradio...")
    
    interface = create_interface()
    
    interface.launch(
        server_name=server_name,
        server_port=server_port,
        share=share,
        debug=debug,
        show_error=True,
        quiet=not debug
    )


if __name__ == "__main__":
    # C·∫•u h√¨nh logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Kh·ªüi ch·∫°y v·ªõi c·∫•u h√¨nh m·∫∑c ƒë·ªãnh
    launch_app(debug=True)
